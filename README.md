# designPatterns-demo
23种设计模式

<table>
   <th>分类</th><th>设计模式</th><th>优点</th><th>缺点</th>
   <tr>
     <td rowspan="4">创建(create)型设计模式<br>（简单来说就是用来创建对象的）</td>
     <td>工厂/抽象工厂模式（Factory Pattern）</td>
     <td>1.不同条件下创建不同实例 2.产品标准化，生产更高效 3.封装创建细节</td>
     <td>1.类的个数增多，增加复杂度 2.增加了系统的抽象性和理解难度</td>
   </tr>
   <tr>
     <td>单例模式（Singleton Pattern）</td>
     <td>1.保证一个类仅有一个实例，并且提供一个全局访问点	2.保证内存里只有一个实例，减少了内存的开销。3.避免资源多重占用 4.优化共享资源访问</td>
     <td>1.一般没有接口，扩展困难，需要扩展则要修改源码，违背了开闭原则 2.在并发测试中不利于代码调试 3.单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</td>
   </tr>
   <tr>
     <td>原型模式（Prototype Pattern）</td>
     <td>1.通过拷贝原型创建新的对象，高效创建对象 2.在性能上比直接 new 一个对象更加优良。</td>
     <td>1.需要为每一个类都配置一个 clone 方法 2.clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。 3.实现深克隆时，需要编写较为复杂的代码</td>
   </tr>
   <tr>
     <td>建造者模式（Builder Pattern）</td>
     <td>1.用来创建复杂的复合对象，开放个性配置 2.封装性好，构建和表示分离。扩展性好，各个具体的建造者相互独立，有利于系统的解耦。
     3.建造者可以对创建过程逐步细化，不对其他模块产生影响，便于控制细节风险</td>
     <td>1.产品的组成部分必须相同，这限制了其使用范围。 2.如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</td>
   </tr>
   <tr>
     <td rowspan="7">结构(structure)型设计模式<br>（关注类和对象的组合）</td>
     <td>代理模式（Proxy Pattern）</td>
     <td>1.为其他对象提供一种代理以控制对这个对象的访问 2.代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性</td>
     <td>1.代理模式会造成系统设计中类的数量增加2.在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；3.增加了系统的复杂度</td>
   </tr>
   <tr>
     <td>外观模式（Facade Pattern）</td>
     <td>1.对外提供一个统一的接口用来访问子系统 2.统一的访问入口 </td>
     <td>1.不能很好地限制客户使用子系统类，很容易带来未知风险。2.增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</td>
   </tr>
   <tr>
     <td>装饰器模式（Decorator Pattern）</td>
     <td>1.为对象添加新功能	2.灵活扩展，同宗同源 3.在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用，符合开闭原则</td>
     <td>2.装饰器模式会增加许多子类，过度使用会增加程序得复杂性。</td>
   </tr>
   <tr>
     <td>享元模式（Flyweight Pattern）</td>
     <td>1.共享资源池，使用对象池来减少重复对象的创建 2.相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</td>
     <td>1.为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。2.读取享元模式的外部状态会使得运行时间稍微变长。</td>
   </tr>
   <tr>
     <td>组合模式（Composite Pattern）</td>
     <td>1.将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理2.客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”</td>
     <td>1.设计复杂，客户端需要花费更多时间梳理类之间的关系2.不容易限制容器中的构件或用继承的方法增加构件的新功能</td>
   </tr>
   <tr>
     <td>适配器模式（Adapter Pattern）</td>
     <td>-</td>
     <td>-</td>
   </tr>
   <tr>
     <td>桥接模式（Bridge Pattern）</td>
     <td>-</td>
     <td>-</td>
   </tr>
   <tr>
     <td rowspan="10">行为(behavior)型设计模式<br>（关注对象之间的通信）</td>
     <td>模板模式（Template Pattern）</td>
     <td>1.定义一套流程模板，根据需要实现模板中的操作 2.流程全部标准化，需要微调请覆盖</td>
     <td>1.对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。
         2.父类中的抽象方法由子类实现，子类的执行结果会影响父类的结果，反向控制结构，提高了代码阅读难度
         3.父类增加方法，子类必须实现</td>
   </tr>
   <tr>
     <td>策略模式（Strategy Pattern）</td>
     <td>1.封装不同的算法，算法之间能互相替换2.可以避免多重判断语句，使用算法族公共代码转移父类，避免重复代码3.策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</td>
     <td>1.客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。2.策略模式造成很多的策略类，增加维护难度。</td>
   </tr>   
   <tr>
     <td>责任链模式（Chain of Responsibility Pattern）</td>
     <td>-</td>
     <td>-</td>
   </tr>
   <tr>
     <td>迭代器模式（Iterator Pattern）	</td>
     <td>-</td>
     <td>-</td>
   </tr>
   <tr>
     <td>命令模式（Command Pattern）	</td>
     <td>-</td>
     <td>-</td>
   </tr>
   <tr>
     <td>状态模式（State Pattern）		</td>
     <td>-</td>
     <td>-</td>
   </tr>
   <tr>
     <td>中介者模式（Mediator Pattern）	</td>
     <td>-</td>
     <td>-</td>
   </tr>
   <tr>
     <td>解释器模式（Interpreter Pattern）	</td>
     <td>-</td>
     <td>-</td>
   </tr>
   <tr>
     <td>观察者模式（Observer Pattern）	</td>
     <td>-</td>
     <td>-</td>
   </tr>
   <tr>
     <td>访问者模式（Visitor Pattern）	</td>
     <td>-</td>
     <td>-</td>
   </tr>
    <tr>
     <td></td>
     <td>委派模式（Delegate Pattern）	</td>
     <td>-</td>
     <td>-</td>
   </tr>
</table>