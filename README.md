# designPatterns-demo
23种设计模式

<table>
   <th>分类</th><th>设计模式</th><th>优点</th><th>缺点</th>
   <tr>
     <td rowspan="4">创建(create)型设计模式<br>（简单来说就是用来创建对象的）</td>
     <td>工厂/抽象工厂模式（Factory Pattern）</td>
     <td>1.不同条件下创建不同实例 2.产品标准化，生产更高效 3.封装创建细节</td>
     <td>1.类的个数增多，增加复杂度 2.增加了系统的抽象性和理解难度</td>
   </tr>
   <tr>
     <td>单例模式（Singleton Pattern）</td>
     <td>1.保证一个类仅有一个实例，并且提供一个全局访问点	2.保证内存里只有一个实例，减少了内存的开销。3.避免资源多重占用 4.优化共享资源访问</td>
     <td>1.一般没有接口，扩展困难，需要扩展则要修改源码，违背了开闭原则 2.在并发测试中不利于代码调试 3.单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</td>
   </tr>
   <tr>
     <td>原型模式（Prototype Pattern）</td>
     <td>1.通过拷贝原型创建新的对象，高效创建对象 2.在性能上比直接 new 一个对象更加优良。</td>
     <td>1.需要为每一个类都配置一个 clone 方法 2.clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。 3.实现深克隆时，需要编写较为复杂的代码</td>
   </tr>
   <tr>
     <td>建造者模式（Builder Pattern）</td>
     <td>1.用来创建复杂的复合对象，开放个性配置 2.封装性好，构建和表示分离。扩展性好，各个具体的建造者相互独立，有利于系统的解耦。
     3.建造者可以对创建过程逐步细化，不对其他模块产生影响，便于控制细节风险</td>
     <td>1.产品的组成部分必须相同，这限制了其使用范围。 2.如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</td>
   </tr>
   <tr>
     <td rowspan="7">结构(structure)型设计模式<br>（关注类和对象的组合）</td>
     <td>代理模式（Proxy Pattern）</td>
     <td>1.为其他对象提供一种代理以控制对这个对象的访问 2.代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性</td>
     <td>1.代理模式会造成系统设计中类的数量增加2.在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；3.增加了系统的复杂度</td>
   </tr>
   <tr>
     <td>外观模式（Facade Pattern）</td>
     <td>1.对外提供一个统一的接口用来访问子系统 2.统一的访问入口 </td>
     <td>1.不能很好地限制客户使用子系统类，很容易带来未知风险。2.增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</td>
   </tr>
   <tr>
     <td>装饰器模式（Decorator Pattern）</td>
     <td>1.为对象添加新功能	2.灵活扩展，同宗同源 3.在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用，符合开闭原则</td>
     <td>2.装饰器模式会增加许多子类，过度使用会增加程序得复杂性。</td>
   </tr>
   <tr>
     <td>享元模式（Flyweight Pattern）</td>
     <td>1.共享资源池，使用对象池来减少重复对象的创建 2.相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</td>
     <td>1.为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。2.读取享元模式的外部状态会使得运行时间稍微变长。</td>
   </tr>
   <tr>
     <td>组合模式（Composite Pattern）</td>
     <td>1.将整体与局部（树形结构）进行递归组合，让客户端能够以一种的方式对其进行处理2.客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”</td>
     <td>1.设计复杂，客户端需要花费更多时间梳理类之间的关系2.不容易限制容器中的构件或用继承的方法增加构件的新功能</td>
   </tr>
   <tr>
     <td>适配器模式（Adapter Pattern）</td>
     <td>1.将原来不兼容的两个类融合在一起	2.复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。3.将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</td>
     <td>1.适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。2.增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</td>
   </tr>
   <tr>
     <td>桥接模式（Bridge Pattern）</td>
     <td>1.将两个能够独立变化的部分分离开来 2.抽象与实现分离，扩展能力强，符合开闭原则，符合合成复用原则，其实现细节对客户透明</td>
     <td>1.由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，能正确地识别出系统中两个独立变化的维度，这增加了系统的理解与设计难度。</td>
   </tr>
   <tr>
     <td rowspan="11">行为(behavior)型设计模式<br>（关注对象之间的通信）</td>
     <td>模板模式（Template Pattern）</td>
     <td>1.定义一套流程模板，根据需要实现模板中的操作 2.流程全部标准化，需要微调请覆盖</td>
     <td>1.对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。
         2.父类中的抽象方法由子类实现，子类的执行结果会影响父类的结果，反向控制结构，提高了代码阅读难度
         3.父类增加方法，子类必须实现</td>
   </tr>
   <tr>
     <td>策略模式（Strategy Pattern）</td>
     <td>1.封装不同的算法，算法之间能互相替换2.可以避免多重判断语句，使用算法族公共代码转移父类，避免重复代码3.策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</td>
     <td>1.客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。2.策略模式造成很多的策略类，增加维护难度。</td>
   </tr>   
   <tr>
     <td>责任链模式（Chain of Responsibility Pattern）</td>
     <td>1.拦截的类都实现统一接口，每个接收者都包含对下一个接收者的引用。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。
         2.增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。3.责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。	</td>
     <td>1.不能保证每个请求都能被处理2.对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。
         3.职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</td>
   </tr>
   <tr>
     <td>迭代器模式（Iterator Pattern）	</td>
     <td>1.提供一种方法顺序访问一个聚合对象中的各个元素2.它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。3.封装性良好，为遍历不同的聚合结构提供一个统一的接口。 </td>
     <td>1.增加了类的个数，这在一定程度上增加了系统的复杂性。</td>
   </tr>
   <tr>
     <td>命令模式（Command Pattern）	</td>
     <td>1.通过引入中间件（抽象接口）降低系统的耦合度。2.扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则”。
     3.可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。
     4.方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。
     5.可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活。</td>
     <td>1.可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性。
       2.命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），
       增加了理解上的困难。不过这也是设计模式的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解。</td>
   </tr>
   <tr>
     <td>状态模式（State Pattern）		</td>
     <td>1.结构清晰，不同状态分割开来，满足单一原则 2.将状态转换显示化，减少对象间的相互依赖。 3.状态类职责明确，有利于程序的扩展</td>
     <td>1.状态的使用会增加类和对象的个数 2.状态模式的结构与实现都较为复杂，使用不当会造成代码混乱 3.状态模式对开闭原则的支持并不太好，</td>
   </tr>
   <tr>
     <td>备忘录模式（Memento Pattern）		</td>
     <td>1.提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。
         2.实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。
         3.简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</td>
     <td>1.资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</td>
   </tr>
   <tr>
     <td>中介者模式（Mediator Pattern）	</td>
     <td>1.类之间各司其职，符合迪米特法则。2.降低了对象之间的耦合性，使得对象易于独立地被复用。3.将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展</td>
     <td>1.中介者模式将原本多个对象直接的相互依赖变成了中介者和多个同事类的依赖关系。当同事类越多时，中介者就会越臃肿，变得复杂且难以维护。</td>
   </tr>
   <tr>
     <td>解释器模式（Interpreter Pattern）	</td>
     <td>1.扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。
        2.容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</td>
     <td>1.执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。
         2.会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。
         3.可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</td>
   </tr>
   <tr>
     <td>观察者模式（Observer Pattern）	</td>
     <td>1.降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。符合依赖倒置原则。2.目标与观察者之间建立了一套触发机制。</td>
     <td>1.目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。2.当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</td>
   </tr>
   <tr>
     <td>访问者模式（Visitor Pattern）	</td>
     <td>1.扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
         2.复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。
         3.灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。
         4.符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</td>
     <td>1.增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。
         2.破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。
         3.违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</td>
   </tr>
</table>
